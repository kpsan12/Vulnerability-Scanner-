import requests
import concurrent.futures
import socket
import ssl
from urllib.parse import urlparse
import json

class ComprehensiveWebScanner:
    def __init__(self, target_url, vuln_db_path):
        self.target_url = target_url
        self.parsed_url = urlparse(target_url)
        self.host = self.parsed_url.netloc
        self.protocol = self.parsed_url.scheme
        self.port = self.parsed_url.port or (443 if self.protocol == 'https' else 80)
        self.results = []
        self.vuln_db_path = vuln_db_path
        self.vulns_db = self.load_vuln_database()

    def load_vuln_database(self):
        with open(self.vuln_db_path, 'r') as f:
            return json.load(f)

    def scan(self):
        print(f"Starting comprehensive scan of {self.target_url}")
        self.results = []  # Clear previous results
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = [
                executor.submit(self.check_server_info),
                executor.submit(self.check_ssl_vulnerabilities),
                executor.submit(self.check_common_misconfigurations),
                executor.submit(self.check_outdated_software),
                executor.submit(self.check_default_files),
                executor.submit(self.check_injection_vulnerabilities),
                executor.submit(self.check_xss_vulnerabilities),
                executor.submit(self.check_ssrf_vulnerabilities),
                executor.submit(self.check_command_injection),
                executor.submit(self.perform_directory_bruteforce)
            ]
            concurrent.futures.wait(futures)

        return self.results

    def check_server_info(self):
        try:
            response = requests.get(self.target_url, timeout=10)
            server = response.headers.get('Server', 'Unknown')
            self.results.append(f"Server: {server}")

            if 'X-Powered-By' in response.headers:
                self.results.append(f"X-Powered-By: {response.headers['X-Powered-By']}")

            if self.protocol == 'https':
                ctx = ssl.create_default_context()
                with ctx.wrap_socket(socket.socket(), server_hostname=self.host) as s:
                    s.connect((self.host, self.port))
                    cert = s.getpeercert()
                    self.results.append(f"SSL Version: {s.version()}")
                    self.results.append(f"Certificate expires: {cert['notAfter']}")
        except Exception as e:
            self.results.append(f"Error checking server info: {str(e)}")

    def check_ssl_vulnerabilities(self):
        if self.protocol != 'https':
            return

        try:
            ctx = ssl.create_default_context()
            with ctx.wrap_socket(socket.socket(), server_hostname=self.host) as s:
                s.connect((self.host, self.port))
                if s.version() in ['TLSv1', 'TLSv1.1']:
                    self.results.append(f"Vulnerable SSL/TLS version: {s.version()}")
        except Exception as e:
            self.results.append(f"Error checking SSL vulnerabilities: {str(e)}")

    def check_common_misconfigurations(self):
        for misconfig in self.vulns_db['misconfigurations']:
            try:
                response = requests.get(f"{self.target_url}{misconfig['path']}", timeout=10)
                if response.status_code == 200 and misconfig['pattern'] in response.text:
                    self.results.append(f"Misconfiguration: {misconfig['issue']} (Severity: {misconfig['severity']})")
            except requests.RequestException:
                pass

    def check_outdated_software(self):
        response = requests.get(self.target_url, timeout=10)
        server = response.headers.get('Server', '').lower()

        for software, versions in self.vulns_db['server_vulnerabilities'].items():
            if software in server:
                for version, vulns in versions.items():
                    if version in server:
                        for vuln in vulns:
                            self.results.append(
                                f"{software} {version} - {vuln['cve']} ({vuln['description']}) - Severity: {vuln['severity']}"
                            )

    def check_default_files(self):
        for file in self.vulns_db['default_files']:
            try:
                response = requests.get(f"{self.target_url}{file}", timeout=10)
                if response.status_code == 200:
                    self.results.append(f"Default file/directory found: {file}")
            except requests.RequestException:
                pass

    def check_injection_vulnerabilities(self):
        for payload in self.vulns_db['injection_payloads']:
            try:
                response = requests.get(f"{self.target_url}?id={payload}", timeout=10)
                if "error" in response.text.lower() or "syntax" in response.text.lower():
                    self.results.append(f"Injection Vulnerability: {payload}")
            except requests.RequestException:
                pass

    def check_xss_vulnerabilities(self):
        for payload in self.vulns_db['xss_payloads']:
            try:
                response = requests.get(f"{self.target_url}?q={payload}", timeout=10)
                if payload in response.text:
                    self.results.append(f"XSS Vulnerability: {payload}")
            except requests.RequestException:
                pass

    def check_ssrf_vulnerabilities(self):
        for payload in self.vulns_db['ssrf_payloads']:
            try:
                response = requests.get(f"{payload}", timeout=10)
                if response.status_code == 200:
                    self.results.append(f"SSRF Vulnerability: {payload}")
            except requests.RequestException:
                pass

    def check_command_injection(self):
        for payload in self.vulns_db['command_injection_payloads']:
            try:
                response = requests.get(f"{self.target_url}?cmd={payload}", timeout=10)
                if response.status_code == 200:
                    self.results.append(f"Command Injection Attempted: {payload}")
            except requests.RequestException:
                pass

    def perform_directory_bruteforce(self):
        for directory in self.vulns_db['common_directories']:
            try:
                response = requests.get(f"{self.target_url}{directory}", timeout=10)
                if response.status_code == 200:
                    self.results.append(f"Directory found: {directory}")
            except requests.RequestException:
                pass
